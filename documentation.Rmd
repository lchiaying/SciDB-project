---
title: "SciDB"
author: "Wusuo Liu and Chia Ying Lee"
date: "5/3/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Installation

Download the virtual machine from <insert Google Docs URL>.

Full documentation of SciDB is provided [here](https://paradigm4.atlassian.net/wiki/display/ESD/SciDB+Documentation).

The `scidb` R package is available on [CRAN](https://cran.r-project.org/package=scidb), along with [documentation](https://cran.r-project.org/web/packages/scidb/vignettes/scidb.pdf).

The virtual machine has R and RStudio server already set up with `scidb` R package installed. (Note the pre-installed version of `scidb` is not the latest version.)


## Start the database

```
$ scidb.py startall mydb
```

# SciDB Data Structures and Query Languages

## AQL and AFL

SciDB provides query languages AQL, for querying the database, and AFL, for performing function calls on database objects. They are accessed from the unix terminal.

```
$ iquery
AQL% set lang AFL;
AFL%
```
## `scidb` R package

The `scidb` R package provides an interface to R, allowing interaction with the database from R, primarily using the `iquery` function.

# Basics of SciDB R package

First, load the library, and connect to the SciDB database. By default, it connects to the localhost.
```{r}
library(scidb, quietly = T)
dbConnect <- scidbconnect()
```

The datasets in the SciDB database can be listed using the following command.

```{r}
(existingArray <- iquery(db = dbConnect, query = "list('arrays')", return = T))
```

The above expression illustrates the basic usage of the `iquery` function: it is told the database to connect to, and the query to run. Setting `return = T` will return the scidb arrary to an R data frame, which we have called `existingArray`. By default, `return = F`, meaning that the query is performed in the SciDB database, but no output is returned to R.

# Data

We use the movie ratings data from [MovieLens](https://grouplens.org/datasets/movielens/).

There are 2 datasets provided, 

- Full data set
- Small data set


## Download data

```{r download_data}
# Get the small dataset
data.dir <- "/home/scidb/Project/ml-latest-small"
if (!dir.exists(data.dir)) {
  download.file("http://files.grouplens.org/datasets/movielens/ml-latest-small.zip", 
                destfile = "/home/scidb/Project/ml-latest-small.zip")
  unzip("/home/scidb/Project/ml-latest-small.zip")
  
  # System command to strip header (first line) from data file ratings.csv
  system(sprintf("tail -n +2 %s/ratings.csv > %s/ratings_noHeader.csv", data.dir, data.dir))
}
rm(data.dir)

# Get the small dataset
data.dir <- "/home/scidb/Project/ml-20m"
if (!dir.exists(data.dir)) {
  download.file("http://files.grouplens.org/datasets/movielens/ml-20m.zip", 
                destfile = "/home/scidb/Project/ml-20m.zip")
  unzip("/home/scidb/Project/ml-20m.zip")
  
  # System command to strip header (first line) from data file ratings.csv
  system(sprintf("tail -n +2 %s/ratings.csv > %s/ratings_noHeader.csv", data.dir, data.dir))
}
rm(data.dir)
```



## Load Data into SciDB

```{r load_small_dataset, eval = F, cache = T}
existingArray = iquery(dbConnect, "list('arrays')", return = T)
if("ratings" %in% existingArray$name) iquery(dbConnect, "remove(ratings)")

iquery(dbConnect, "CREATE ARRAY ratings <userId:int64, movieID:int64, rating:double NOT NULL, timestamp:int64> [i=0:?,1000000,0]")
# Note: It's important to make rating column NOT NULL, to enable the use of spgemm later on.

iquery(dbConnect, "load(ratings, '/home/scidb/Project/ml-latest-small/ratings_noHeader.csv', -2, 'csv')")
```


```{r}
(m_max <- iquery(dbConnect, "aggregate(ratings, max(movieID))", return = T))
(u_max <- iquery(dbConnect, "aggregate(ratings, max(userId))", return = T))

(n_ratings <- iquery(dbConnect, "aggregate(ratings, count(*))", return = T))
```

The movieIDs range from 1 to 163949. The userIds range from 1 to 671. There are 100004 ratings available. The matrix is huge but very sparse.

Redimension it so that userId is the first dimension (rows) and movieID is the second dimension (columns).

```{r}
existingArray = iquery(dbConnect, "list('arrays')", return = T)
if("ratings_matrix" %in% existingArray$name) iquery(dbConnect, "remove(ratings_matrix)")

iquery(dbConnect, "store(redimension(ratings, <rating:double NOT NULL>[userId=0:671,?,0,movieID=0:163949,?,0]), ratings_matrix)")
```

Below is the corresponding code for loading the full dataset into SciDB.

```{r load_full_dataset, eval = F, cache=T}
iquery(dbConnect, "CREATE ARRAY RATINGS <userId:int64, movieID:int64, rating:double NOT NULL, timestamp:int64> [i=0:?,1000000,0]")

iquery(dbConnect, "load(RATINGS, '/home/scidb/Project/ml-20m/ratings_noHeader.csv', -2, 'csv')")

m_max <- iquery(dbConnect, "aggregate(RATINGS, max(movieID))", return = T)$movieID_max
u_max <- iquery(dbConnect, "aggregate(RATINGS, max(userId))", return = T)$userId_max

query <- sprintf("store(redimension(RATINGS, <rating:double NOT NULL>[userId=0:%d,?,0,movieID=0:%d,?,0]), RATINGS_MATRIX)",
                 u_max, m_max)
iquery(dbConnect, query)
```

# Doing Fun Stuff with the Data

## Visualize ratings as image

We can try to visualize the matrix using the `image` function provided in `vm_functions.R`.

```{r}
source("~/vm_functions.R")

ratings_matrix <- scidb("ratings_matrix")
system.time(image(ratings_matrix, grid = c(100,10)))
```

## Compute correlation
Now, let's try to compute the correlation between users. Since `userId` is in rows, we just have to normalize the rows and matrix multiply $M * M^T$.

The SciDB function for sparse matix multiply is `spgemm`, in the `linear_algebra` library.

```{r load_linear_algebra_library}
iquery(dbConnect, "load_library('linear_algebra')")
```


```{r spgemm_small_data, eval=F}
ratings_matrix_MxMT <- iquery(
  dbConnect, 
  "store(spgemm(ratings_matrix, transpose(ratings_matrix)), ratings_matrix_MxMT)", 
  return = T)

head(ratings_matrix_MxMT)
```


```{r spgemm_full_data, eval=F}
system.time(
  iquery(dbConnect, 
         "store(spgemm(RATINGS_MATRIX, transpose(RATINGS_MATRIX)), RATINGS_MATRIX_MxMT)")
)
```


## SVD

```{r}
iquery(dbConnect, "load_library('dense_linear_algebra')")
```

```{r normalize_small_data, eval = F}
query_userAvg <- "aggregate(ratings_matrix, avg(rating), userId)"
query_crossjoin <- sprintf("cross_join(ratings_matrix as A, %s as B, A.userId, B.userId)",
                           query_userAvg)
query_center <- sprintf("project(apply(%s, rating_centered, rating - rating_avg), rating_centered)",
                           query_crossjoin)

ratings_matrix_normalized <- iquery(dbConnect, 
                                    sprintf("store(%s, ratings_matrix_centered)", query_center),
                                    return = T)
```


```{r gesvd_small_data, eval = F, cache = T}
ratings_singularValues <- iquery(dbConnect, 
                                 "store(gesvd(ratings_matrix, 'S'), ratings_singularValues)", 
                                 return = T)
```



```{r}
plot(ratings_singularValues)
```