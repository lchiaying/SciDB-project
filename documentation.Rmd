---
title: "SciDB"
author: "Wusuo Liu and Chia Ying Lee"
date: "5/3/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Installation

Download the virtual machine from <insert Google Docs URL>.

Full documentation of SciDB is provided [here](https://paradigm4.atlassian.net/wiki/display/ESD/SciDB+Documentation).

The `scidb` R package is available on [CRAN](https://cran.r-project.org/package=scidb), along with [documentation](https://cran.r-project.org/web/packages/scidb/vignettes/scidb.pdf).

The virtual machine has R and RStudio server already set up with `scidb` R package installed. (Note the pre-installed version of `scidb` is not the latest version.)

# SciDB query

Uses the AFL query language blah blah blah.

# Basics of SciDB R package

First, load the library, and connect to the SciDB database.
```{r}
library(scidb, quietly = T)
scidbconnect()
```

The VM's SciDB database already contains several datasets. We can list them.
```{r}
scidblist()
```

To build a new dataset in the database, we use the `build` function to create an AFL query expression, then `scidbeval` to evaluate it into an actual SciDB data object. 

As an example, we create a sparse matrix as follows:

```{r}
x <- build("<v:double>[i=1:2,2,0, j=1:3,1,0], i*j)", dim = c(3,4))
scidbeval(x, name = "test") # Give the dataset a meaningful name
```

Now the matrix is in the SciDB database. Let's load it into R as a `scidb` object.
```{r}
x.scidb <- scidb("test") # Retrieve the dataset by its name
print(x.scidb)
```


# Data

## Download data

We use the movie ratings data from [MovieLens](https://grouplens.org/datasets/movielens/).


```{r}
# Get the small dataset
data.dir <- "ml-latest-small"
if (!dir.exists(data.dir)) {
  download.file("http://files.grouplens.org/datasets/movielens/ml-latest-small.zip", 
                destfile = "ml-20m.zip")
  unzip("ml-20m.zip")
}
```


## Load Data into R

```
$ iquery
AQL% set lang AFL;
AFL%
```

```
AFL% CREATE ARRAY ratings <userId:int64, movieID:int64, rating:double, timestamp:int64> [i=1:700,1000000,0]
AFL% load(ratings, '/home/scidb/Project/ml-latest-small/ratings_0.csv', -2, 'csv');
AFL% store(redimension(ratings, <val:double>[userId=1:*,?,0,movieID=1:*,?,0]), ratings_matrix);
```

```{r}
if ("ratings" %in% scidbls()) iquery("remove(ratings);")
iquery("CREATE ARRAY ratings <userId:int64, movieID:int64, rating:double NOT NULL, timestamp:int64> [i=1:?,1000000,0];")
# Note: It's important to make rating column NOT NULL, to enable the use of spgemm later on.
```

```{r}
iquery("load(ratings, '/home/scidb/Project/ml-latest-small/ratings_0.csv', -2, 'csv');")
```

```{r}
(m_min <- iquery("aggregate(ratings, min(movieID));", return = T))
(m_max <- iquery("aggregate(ratings, max(movieID));", return = T))

(u_min <- iquery("aggregate(ratings, min(userId));", return = T))
(u_max <- iquery("aggregate(ratings, max(userId));", return = T))

(n_ratings <- iquery("aggregate(ratings, count(*));", return = T))
```

The movieIDs range from 1 to 163949. The userIds range from 1 to 671. There are 100004 ratings available. The matrix is huge but very sparse.

Redimension it so that userId is the first dimension (rows) and movieID is the second dimension (columns).

```{r}
if ("ratings_matrix" %in% scidbls()) iquery("remove(ratings_matrix);")
iquery("store(redimension(ratings, <rating:double NOT NULL>[userId=1:671,?,0,movieID=1:163949,?,0]), ratings_matrix);")
```

We can try to visualize the matrix using the `image` function provided in `vm_functions.R`.

```{r}
source("~/vm_functions.R")

ratings_matrix <- scidb("ratings_matrix")
system.time(image(ratings_matrix, grid = c(100,10)))
```

Now, let's try to compute the correlation between users. Since `userId` is in rows, we just have to normalize the rows and matrix multiply $M * M^T$.

```{r}
# Figure out how to normalize the data first

system.time(corr <- iquery("spgemm(ratings_matrix, transpose(ratings_matrix));", 
                           return = T))

head(corr)
```


