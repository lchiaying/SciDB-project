---
title: "SciDB"
author: "Wusuo Liu and Chia Ying Lee"
date: "5/3/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Installation

Download the virtual machine from <insert Google Docs URL>.

Full documentation of SciDB is provided [here](https://paradigm4.atlassian.net/wiki/display/ESD/SciDB+Documentation).

The `scidb` R package is available on [CRAN](https://cran.r-project.org/package=scidb), along with [documentation](https://cran.r-project.org/web/packages/scidb/vignettes/scidb.pdf).

The virtual machine has R and RStudio server already set up with `scidb` R package installed. (Note the pre-installed version of `scidb` is not the latest version.)


![This is a figure](..../.png)

## Start the database

```
$ scidb.py startall mydb
```

# SciDB Data Structures and Query Languages

## AQL and AFL

SciDB provides query languages AQL, for querying the database, and AFL, for performing function calls on database objects. They are accessed from the unix terminal.

```
$ iquery
AQL% set lang AFL;
AFL%
```
## `scidb` R package

The `scidb` R package provides an interface to R, allowing interaction with the database from R, primarily using the `iquery` function.

# Basics of SciDB R package

First, load the library, and connect to the SciDB database. By default, it connects to the localhost.
```{r}
library(scidb, quietly = T)
dbConnect <- scidbconnect()
```

The datasets in the SciDB database can be listed using the following command.

```{r}
(existingArray <- iquery(db = dbConnect, query = "list('arrays')", return = T))
```

The above expression illustrates the basic usage of the `iquery` function: it is told the database to connect to, and the query to run. Setting `return = T` will return the scidb arrary to an R data frame, which we have called `existingArray`. By default, `return = F`, meaning that the query is performed in the SciDB database, but no output is returned to R.

# Data

We use the movie ratings data from [MovieLens](https://grouplens.org/datasets/movielens/).

There are 2 datasets provided, 

- Full data set
- Small data set


## Download data

```{r download_small_dataset}
# Get the small dataset
data.dir <- "/home/scidb/Project/ml-latest-small"
if (!dir.exists(data.dir)) {
  download.file("http://files.grouplens.org/datasets/movielens/ml-latest-small.zip", 
                destfile = "/home/scidb/Project/ml-latest-small.zip")
  unzip("/home/scidb/Project/ml-latest-small.zip")
  
  # System command to strip header (first line) from data file ratings.csv
  system(sprintf("tail -n +2 %s/ratings.csv > %s/ratings_noHeader.csv", data.dir, data.dir))
}
rm(data.dir)

# Get the small dataset
data.dir <- "/home/scidb/Project/ml-20m"
if (!dir.exists(data.dir)) {
  download.file("http://files.grouplens.org/datasets/movielens/ml-20m.zip", 
                destfile = "/home/scidb/Project/ml-20m.zip")
  unzip("/home/scidb/Project/ml-20m.zip")
  
  # System command to strip header (first line) from data file ratings.csv
  system(sprintf("tail -n +2 %s/ratings.csv > %s/ratings_noHeader.csv", data.dir, data.dir))
}
rm(data.dir)
```



## Load Data into SciDB

```{r}
existingArray = iquery(db = dbConnect, "list('arrays')", return = T)
if("ratings" %in% existingArray$name) iquery(dbConnect, "remove(ratings)")

iquery(dbConnect, "CREATE ARRAY ratings <userId:int64, movieID:int64, rating:double NOT NULL, timestamp:int64> [i=0:?,1000000,0]")
# Note: It's important to make rating column NOT NULL, to enable the use of spgemm later on.
```

```{r}
iquery(dbConnect, "load(ratings, '/home/scidb/Project/ml-latest-small/ratings_noHeader.csv', -2, 'csv')")
```

```{r}
(m_min <- iquery(dbConnect, "aggregate(ratings, min(movieID))", return = T))
(m_max <- iquery(dbConnect, "aggregate(ratings, max(movieID))", return = T))

(u_min <- iquery(dbConnect, "aggregate(ratings, min(userId))", return = T))
(u_max <- iquery(dbConnect, "aggregate(ratings, max(userId))", return = T))

(n_ratings <- iquery(dbConnect, "aggregate(ratings, count(*))", return = T))
```

The movieIDs range from 1 to 163949. The userIds range from 1 to 671. There are 100004 ratings available. The matrix is huge but very sparse.

Redimension it so that userId is the first dimension (rows) and movieID is the second dimension (columns).

```{r}
existingArray = iquery(dbConnect, "list('arrays')", return = T)
if("ratings_matrix" %in% existingArray$name) iquery(dbConnect, "remove(ratings_matrix)")

iquery(dbConnect, "store(redimension(ratings, <rating:double NOT NULL>[userId=0:671,?,0,movieID=0:163949,?,0]), ratings_matrix)")
```

### Plot image

We can try to visualize the matrix using the `image` function provided in `vm_functions.R`.

```{r}
source("~/vm_functions.R")

ratings_matrix <- scidb("ratings_matrix")
system.time(image(ratings_matrix, grid = c(100,10)))
```

### Compute correlation
Now, let's try to compute the correlation between users. Since `userId` is in rows, we just have to normalize the rows and matrix multiply $M * M^T$.

```{r}
# Figure out how to normalize the data first

iquery(dbConnect, "load_library('linear_algebra')")

system.time(corr <- iquery(dbConnect, 
                           "spgemm(ratings_matrix, transpose(ratings_matrix))", 
                           return = T))

head(corr)
```



### SVD

```{r}
iquery(dbConnect, "load_library('dense_linear_algebra')")
```

```{r cache = T}
ratings_singularValues <- iquery(dbConnect, "store(gesvd(ratings_matrix, 'S'), ratings_singularValues)", return = T)
```
```{r}
plot(ratings_singularValues)
```